import fs from "fs";
import path from "path";
import url from "url";

import { Networked3dWebExperienceServer } from "@mml-io/3d-web-experience-server";
import { CharacterDescription } from "@mml-io/3d-web-user-networking";
import dotenv from "dotenv";
import express from "express";
import enableWs from "express-ws";

import { BasicUserAuthenticator } from "./BasicUserAuthenticator";
import { ReactMMLDocumentServer } from "./ReactMMLDocumentServer";

dotenv.config();

const dirname = url.fileURLToPath(new URL(".", import.meta.url));
const PORT = process.env.PORT || 8080;
const webClientBuildDir = path.join(dirname, "../../web-client/build/");
const assetsDir = path.join(dirname, "../../assets/");
const indexContent = fs.readFileSync(path.join(webClientBuildDir, "index.html"), "utf8");
const MML_DOCUMENT_PATH = path.join(dirname, "../../playground/build/index.js");
const examplesWatchPath = path.resolve(path.join(dirname, "../examples"), "*.html");

// Specify the avatar to use here:
const characterDescription: CharacterDescription = {
  // Option 1 (Default) - Use a GLB file directly
  //meshFileUrl: "https://mmlstorage.com/cIzlm5/1729698857259.html", // This is just an address of a GLB file
  // Option 2 - Use an MML Character from a URL
  // mmlCharacterUrl: "https://...",
  // Option 3 - Use an MML Character from a string
   mmlCharacterString: `
  <m-character src="https://mmlstorage.com/01f93b4fc212573febbec2f3131639402300f3fd525756f0a259456558bb1337" collide="false" y="0.04">
    <m-model socket="head" src="https://mmlstorage.com/75bd23339b5d30dbad9a687150cdd87f3d9b60581647ab4d6a284010f6d8d073" rz="-90" sx="1.01" sy="1.01" sz="1.01" x="0.025" y="0" z="-0.01" collide="false" id="hat"></m-model>
    <m-image socket="head" src="https://mmlstorage.com/373bd18d96a476a89e912e1ef5bde6171b82c28797f9202fc9752ab4f67bd0e9" x="0.5" rz="-90"></m-image>
  </m-character>

  <script>
    const hat = document.getElementById("hat");

    let socketIndex = 0;
    const sockets = ["head", "hand_l", "hand_r"];

    const socketsAttributes = [{
        x: 0.025,
        z: -0.01,
        rz: -90
      },
      {
        x: 0.06,
        z: 0.0,
        rz: -90
      },
      {
        x: -0.06,
        z: -0.08,
        rz: 90
      },
    ]

    const handleClick = () => {
      socketIndex = (socketIndex + 1) % sockets.length;
      hat.setAttribute("socket", sockets[socketIndex]);
      for (const key in socketsAttributes[socketIndex]) {
        hat.setAttribute(key, socketsAttributes[socketIndex][key]);
      }
    };

    hat.addEventListener("click", () => handleClick());
  </script>`,
};
const userAuthenticator = new BasicUserAuthenticator(characterDescription, {
  /*
   This option allows sessions that are reconnecting from a previous run of the server to connect even if the present a
   session token that was not generated by this run of the server.

   This is useful for development, but in deployed usage, it is recommended to set this to false.
  */
  devAllowUnrecognizedSessions: true,
});

const { app } = enableWs(express());
app.enable("trust proxy");

const reactMMLDocumentServer = new ReactMMLDocumentServer({
  mmlDocumentPath: MML_DOCUMENT_PATH,
  useWss: process.env.NODE_ENV === "production" || process.env.CODESANDBOX_HOST !== undefined,
});

// Handle playground document sockets
app.ws("/playground", (ws) => {
  reactMMLDocumentServer.handle(ws);
});

const networked3dWebExperienceServer = new Networked3dWebExperienceServer({
  networkPath: "/network",
  userAuthenticator,
  mmlServing: {
    documentsWatchPath: examplesWatchPath,
    documentsUrl: "/examples/",
  },
  webClientServing: {
    indexUrl: "/",
    indexContent,
    clientBuildDir: webClientBuildDir,
    clientUrl: "/web-client/",
    clientWatchWebsocketPath:
      process.env.NODE_ENV !== "production" ? "/web-client-build" : undefined,
  },
  chatNetworkPath: "/chat-network",
  assetServing: {
    assetsDir,
    assetsUrl: "/assets/",
  },
});
networked3dWebExperienceServer.registerExpressRoutes(app);

// Start listening
console.log("Listening on port", PORT);
app.listen(PORT);
